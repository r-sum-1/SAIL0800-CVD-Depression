 -- Create GP_Hist Table
 -- Replace dates to end of study...
DROP TABLE SAILW0800V.GPHist;

CREATE TABLE SAILW0800V.GPHist AS (SELECT * FROM SAIL0800V.WDSD_AR_PERS_GP_20220131) WITH NO DATA;

INSERT INTO SAILW0800V.GPHist (SELECT * FROM SAIL0800V.WDSD_AR_PERS_GP_20220131);

UPDATE SAILW0800V.GPHist 
SET TO_DT =  '2019-12-31' WHERE TO_DT > '2019-12-31';

-- remove NULLS
SELECT COUNT(*) FROM SAILW0800V.GPHist;
--19523060

DELETE FROM SAILW0800V.GPHist 
WHERE PERS_ID_PE IS NULL;

DELETE FROM SAILW0800V.GPHist 
WHERE FROM_DT IS NULL;

DELETE FROM SAILW0800V.GPHist 
WHERE TO_DT IS NULL;

DELETE FROM SAILW0800V.GPHist 
WHERE PRAC_CD_PE IS NULL;
-- removed 174920 records

DELETE FROM SAILW0800V.GPHist 
WHERE FROM_DT > TO_DT;
-- removed 2997145 rows

DROP TABLE SAILW0800V.GPHist_Step_1 ;

-- step 1, when to people get > 365 days of history?
-- The date the person will have enough history will be caculated by...
	-- Creating a running total of days for each person in days based on their periods of GP registration (RUNNING_TOTAL)
	-- create a binary variable where > 365 is 1 and < is 0... This is used for step 2 (CHANGE_POINT)
	-- Calculate the days to subtract (DS_TO_SUB) -- NB read step 2 for this logic...
	
	-- The exact date of enough history will be located by using the binary column (CHANGE_POINT)
	-- Filter only the row with the minimum (FROM_DATE) where the CHANGE_POINT = 1.
	-- This will provide the period of time where the person surpasses 365 days of GP registration.
	-- In table 2, a new column will be generated (TO_DT - DS_TO_SUB DAYS AS ENOUGH_HIST).


CREATE TABLE SAILW0800V.GPHist_Step_1 AS (
SELECT PERS_ID_PE, FROM_DT, TO_DT, PRAC_CD_PE, 
	ROUND(DAYS_BETWEEN(TO_DT, FROM_DT), 0) AS "DS",
	SUM(ROUND(DAYS_BETWEEN(TO_DT, FROM_DT), 0)) OVER (PARTITION BY PERS_ID_PE ORDER BY FROM_DT) AS "RUNNING_TOTAL",
	ABS(365 - SUM(ROUND(DAYS_BETWEEN(TO_DT, FROM_DT), 0)) OVER (PARTITION BY PERS_ID_PE ORDER BY FROM_DT)) AS DS_TO_SUB,
	CASE WHEN SUM(ROUND(DAYS_BETWEEN(TO_DT, FROM_DT), 0)) OVER (PARTITION BY PERS_ID_PE ORDER BY FROM_DT) > 365 THEN 1
		ELSE 0 END AS CHANGE_POINT
			FROM SAILW0800V.GPHist) WITH NO DATA;
			

		
INSERT INTO SAILW0800V.GPHist_Step_1 (
SELECT PERS_ID_PE, FROM_DT, TO_DT, PRAC_CD_PE, 
	ROUND(DAYS_BETWEEN(TO_DT, FROM_DT), 0) AS "DS",
	SUM(ROUND(DAYS_BETWEEN(TO_DT, FROM_DT), 0)) OVER (PARTITION BY PERS_ID_PE ORDER BY FROM_DT) AS "RUNNING_TOTAL",
	ABS(365 - SUM(ROUND(DAYS_BETWEEN(TO_DT, FROM_DT), 0)) OVER (PARTITION BY PERS_ID_PE ORDER BY FROM_DT)) AS DS_TO_SUB,
	CASE WHEN SUM(ROUND(DAYS_BETWEEN(TO_DT, FROM_DT), 0)) OVER (PARTITION BY PERS_ID_PE ORDER BY FROM_DT) > 365 THEN 1
		ELSE 0 END AS CHANGE_POINT
			FROM SAILW0800V.GPHist);
			


SELECT COUNT(UNIQUE(PERS_ID_PE)) FROM SAILW0800V.GPHist_Step_1 ;
-- 5452369

-- step 2, when does the person have enough GP history to enter the cohort?
-- New column ENOUGH HIST... 
-- Filter for minimum FROM_DT where CHANGE_POINT is 1...

DROP TABLE  SAILW0800V.GPHist_Step_2;

CREATE TABLE  SAILW0800V.GPHist_Step_2 AS (
SELECT PERS_ID_PE, TO_DT - DS_TO_SUB DAYS AS ENOUGH_HIST FROM SAILW0800V.GPHist_Step_1 l
		WHERE CHANGE_POINT = 1
		AND FROM_DT = (SELECT MIN(FROM_DT)
			FROM SAILW0800V.GPHist_Step_1 r
			WHERE l.PERS_ID_PE = r.PERS_ID_PE)) WITH DATA;
		
DROP TABLE SAILW0800V.GPHist_Step_3;

 -- step 3, when does the person exit the cohort (need to remove deaths in another step)...
		
CREATE TABLE  SAILW0800V.GPHist_Step_3 AS (
SELECT PERS_ID_PE, TO_DT AS EXIT_COHORT FROM SAILW0800V.GPHist_Step_1 l
		WHERE CHANGE_POINT = 1
		AND TO_DT = (SELECT MAX(TO_DT)
			FROM SAILW0800V.GPHist_Step_1 r
			WHERE l.PERS_ID_PE = r.PERS_ID_PE)) WITH DATA;


 -- Step 4... Include date of death

DROP TABLE SAILW0800V.GPHist_Step_4;

CREATE TABLE SAILW0800V.GPHist_Step_4 AS (
SELECT l.PERS_ID_PE, r1.ALF_PE, r1.GNDR_CD, r1.WOB, l.ENOUGH_HIST, r.EXIT_COHORT, r1.DOD FROM SAILW0800V.GPHist_Step_2 l
LEFT JOIN (SELECT * FROM SAILW0800V.GPHist_Step_3) AS r
ON l.PERS_ID_PE = r.PERS_ID_PE
LEFT JOIN (SELECT * FROM SAIL0800V.WDSD_AR_PERS_20220131) AS r1
ON l.PERS_ID_PE = r1.PERS_ID_PE) WITH DATA;


 -- Calculate date of 18th birthday

ALTER TABLE SAILW0800V.GPHist_Step_4
ADD COLUMN AGE_18		DATE;

UPDATE SAILW0800V.GPHist_Step_4
SET AGE_18 =  WOB + 18 YEARS;


ALTER TABLE SAILW0800V.GPHist_Step_4
ADD COLUMN	ENTER_COHORT 	DATE;


-- Using GP history and date of 18th birthday, identify when someone is eligable to enter the cohort...
-- If both criteria are before 2010, then set it as 2010.
-- etc etc.

UPDATE SAILW0800V.GPHist_Step_4 SET ENTER_COHORT = 
	CASE 
	WHEN (ENOUGH_HIST < '2010-01-01' AND AGE_18 < '2010-01-01') THEN '2010-01-01'
	WHEN ((ENOUGH_HIST > '2010-01-01' OR AGE_18 > '2010-01-01') AND ENOUGH_HIST < AGE_18) THEN AGE_18
	WHEN ((ENOUGH_HIST > '2010-01-01' OR AGE_18 > '2010-01-01') AND AGE_18 < ENOUGH_HIST) THEN ENOUGH_HIST
	WHEN (ENOUGH_HIST > '2019-12-31' OR AGE_18 > '2019-12-31' OR ENOUGH_HIST = NULL OR AGE_18 = NULL) THEN NULL
 		ELSE
		NULL
		END ;
 


-- The last step is to remove people who died before our cohort started..
-- if someone dies before 2010, their start date will be whatever it is, but their exit date will be before 2010...

DROP TABLE SAILW0800V.GPHist_Step_5a;


-- remove duplicates.. generate a row-number grouped by ALF_PE, then select only the first entry... 

CREATE TABLE SAILW0800V.GPHist_Step_5a AS (
SELECT ALF_PE, PERS_ID_PE, GNDR_CD, WOB, ENOUGH_HIST, EXIT_COHORT, 
DOD, AGE_18, ENTER_COHORT, DAYS_BETWEEN(EXIT_COHORT, ENTER_COHORT
) AS DAYS_IN_COHORT,
ROW_NUMBER() OVER (PARTITION BY ALF_PE ORDER BY ALF_PE)  AS row_num 
FROM SAILW0800V.GPHist_Step_4
WHERE ENTER_COHORT < '2019-12-31'
AND EXIT_COHORT > '2010-01-01'
AND ENTER_COHORT < EXIT_COHORT
ORDER BY ALF_PE) WITH DATA;


DROP TABLE SAILW0800V.GPHist_Step_5;

-- remove duplcates part 2... filter only first row

CREATE TABLE SAILW0800V.GPHist_Step_5 AS (SELECT * FROM SAILW0800V.GPHist_Step_5a
WHERE ROW_NUM = 1) WITH DATA;

ALTER TABLE SAILW0800V.GPHist_Step_5
ADD COLUMN	LSOA2011_CD 	VARCHAR(10);


UPDATE SAILW0800V.GPHist_Step_5 tgt
SET tgt.LSOA2011_CD = src.LSOA2011_CD
FROM (SELECT UNIQUE r.ALF_PE, l.START_DATE, l.END_DATE, l.LSOA2011_CD, r.ENTER_COHORT FROM SAIL0800V.WDSD_CLEAN_ADD_LSOA2011_20220131 l
	LEFT JOIN (SELECT UNIQUE ALF_PE, ENTER_COHORT FROM SAILW0800V.GPHist_Step_5) AS r
	ON l.ALF_PE = r.ALF_PE
	WHERE r.ENTER_COHORT BETWEEN l.START_DATE AND l.END_DATE
	ORDER BY ALF_PE) AS src
	WHERE tgt.ALF_PE = src.ALF_PE;
	



-- Some people don't have LSOA at the time of cohort entry... find those people, assign last known
 -- NOTE ABS diff date... we just want closest to entry, doesn't matter if before after...
 -- to do thta, it's based on this query...

DROP TABLE SAILW0800V.GPHist_Step_6; 		
		
CREATE TABLE SAILW0800V.GPHist_Step_6 AS (
SELECT l.ALF_PE,l.LSOA2011_CD AS OLD_LSOA, l.ENTER_COHORT, r.START_DATE, r.END_DATE, r.LSOA2011_CD, ABS(ENTER_COHORT - START_DATE) AS DIFF_DAYS FROM SAILW0800V.GPHist_Step_5 l
LEFT JOIN (SELECT * FROM SAIL0800V.WDSD_CLEAN_ADD_LSOA2011_20220131) AS r
ON l.ALF_PE = r.ALF_PE
WHERE l.LSOA2011_CD IS NULL
AND START_DATE IS NOT NULL) WITH DATA;

DROP TABLE SAILW0800V.GPHist_Step_7;

CREATE TABLE SAILW0800V.GPHist_Step_7 AS (SELECT DISTINCT(l.ALF_PE), l.LSOA2011_CD FROM SAILW0800V.GPHist_Step_6 l
		WHERE DIFF_DAYS = (SELECT MIN(DIFF_DAYS)
			FROM SAILW0800V.GPHist_Step_6 r
			WHERE l.ALF_PE = r.ALF_PE)) WITH DATA;


-- update the main table again...
-- the groupby doesn't really do anything here, but it was throwing an error without it...

UPDATE SAILW0800V.GPHist_Step_5 tgt
SET tgt.LSOA2011_CD = src.LSOA2011_CD
FROM (SELECT DISTINCT ALF_PE, min(LSOA2011_CD) AS LSOA2011_CD FROM SAILW0800V.GPHist_Step_7 GROUP BY ALF_PE) AS src		
	WHERE tgt.ALF_PE = src.ALF_PE;



-- SAVE THE FINAL AND DROP OTHER TABLES
DROP TABLE SAILW0800V.COHORT_ENTRY;
	
CREATE TABLE SAILW0800V.COHORT_ENTRY LIKE SAILW0800V.GPHist_Step_5;
INSERT INTO SAILW0800V.COHORT_ENTRY SELECT * FROM SAILW0800V.GPHist_Step_5;


